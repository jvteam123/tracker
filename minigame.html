<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Stick War Arena | Neon Combat</title>
    <!-- Using Inter font from Google Fonts and Tailwind for utility styling -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom CSS for a cool, professional game aesthetic */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #100f2e 0%, #08081a 100%); /* Deep space gradient */
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better screen usage */
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px;
            overflow-y: auto;
        }

        .game-container {
            background-color: #1c1c3f; /* Darker, sophisticated base */
            border: 2px solid #00f2e0; /* Neon cyan primary border */
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(0, 242, 224, 0.2), 0 0 60px rgba(242, 0, 80, 0.1); /* Subtle dual glow */
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        h1 {
            color: #ffeb3b; /* Vibrant gold text for title */
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.6);
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: 900;
            letter-spacing: 2px;
        }

        #gameCanvas {
            border: 4px solid #f20050; /* Neon pink accent border */
            background-color: #0d0d1a;
            border-radius: 12px;
            touch-action: none; 
            width: 100%; 
            max-width: 860px;
            aspect-ratio: 16 / 9; 
            box-shadow: 0 0 15px rgba(242, 0, 80, 0.5);
        }

        /* Sleek Info Bar Styling */
        .info-bar-item {
            padding: 8px 16px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 242, 224, 0.4);
            font-size: 0.8rem;
            text-shadow: 0 0 5px rgba(0, 242, 224, 0.5);
        }

        /* Professional Button Styling */
        #google-signin-btn {
            background: linear-gradient(90deg, #4285f4, #2a73e8);
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.5);
            transition: all 0.2s ease-in-out;
        }
        #google-signin-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.7);
        }

        /* Controls Section Styling */
        .controls {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            width: 100%;
            max-width: 860px;
            border-top: 1px solid #00f2e0;
        }

        .controls table {
            font-size: 0.85em;
        }

        .controls th {
            color: #ffeb3b;
        }

        .controls td {
            color: #b3e5fc; /* Light blue for key names */
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 5px 8px;
            font-family: monospace;
            text-transform: uppercase;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            .info-bar {
                flex-direction: column;
                gap: 8px;
            }
            .info-bar-item {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
            .controls table {
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-3xl">ONLINE STICK WAR ARENA</h1>
    
    <!-- AUTHENTICATION & INFO BAR (Sleek, horizontal UI) -->
    <div id="auth-ui" class="info-bar flex justify-between items-center w-full max-w-lg mb-4 p-2">
        <div id="player-info" class="info-bar-item break-all" style="display:none;"></div>

        <!-- Status & Sign-in container -->
        <div class="flex flex-col items-end sm:flex-row sm:items-center gap-3">
             <p id="user-status" class="text-sm text-yellow-300">Initializing...</p>
             <button id="google-signin-btn" class="font-bold py-2 px-4 rounded-lg shadow-lg" style="display:none;">
                 Sign in with Gmail
             </button>
        </div>
    </div>
    
    <!-- GAME SECTION -->
    <canvas id="gameCanvas" width="760" height="427"></canvas>
    
    <div id="message-box" class="mt-4 h-8 text-lg font-bold text-center text-red-500 shadow-sm"></div>

    <div class="controls">
        <h2 class="text-xl font-bold text-center mb-4" style="color:#00f2e0;">GLOBAL COMMANDS</h2>
        <table class="w-full text-left">
            <thead>
                <tr>
                    <th class="w-1/3">ACTION</th>
                    <th class="w-2/3">KEY</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Movement</td>
                    <td>A (Left) / D (Right)</td>
                </tr>
                <tr>
                    <td>Jump</td>
                    <td>W</td>
                </tr>
                <tr>
                    <td>Crouch (Hold)</td>
                    <td>S</td>
                </tr>
                <tr>
                    <td>**SWORD ATTACK** (Melee)</td>
                    <td>F</td>
                </tr>
                <tr>
                    <td>**GUN FIRE** (Ranged)</td>
                    <td>G</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script type="module">
    // --- FIREBASE IMPORTS ---
    // Note: The imports use the stable Firebase 11.6.1 version.
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Set Firestore log level to debug for development
    setLogLevel('Debug');

    // --- FIREBASE CONFIGURATION (Hardcoded with user's provided data) ---
    const CONFIG = {
        apiKey: "AIzaSyDVWkdPgYRUK9RZl6enJGmqLXl5wrISt7M",
        authDomain: "minigame-3ea0a.firebaseapp.com",
        projectId: "minigame-3ea0a",
        storageBucket: "minigame-3ea0a.firebasestorage.app",
        messagingSenderId: "937404427991",
        appId: "1:937404427991:web:2bb29763acbe438f794a92"
    };

    let app, db, auth;
    let localPlayerId = null;
    let localPlayer = null;
    let remotePlayers = {}; // Dictionary to hold all remote player states
    let keepAliveInterval = null; 
    
    // --- GAME INITIALIZATION ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('message-box');
    const googleSignInBtn = document.getElementById('google-signin-btn');
    const userStatus = document.getElementById('user-status');
    const playerInfoDiv = document.getElementById('player-info');
    
    // --- GAME CONSTANTS ---
    const GRAVITY = 0.5;
    const FLOOR = canvas.height - 27; // Set main ground floor at Y=400
    const JUMP_VELOCITY = -12;
    const MOVE_SPEED = 4;
    const COOLDOWN_TIME = 300; // ms
    const HIT_FLASH_DURATION = 100; // ms for the red flash
    // Interpolation speed: Higher value means snappier/less smooth, lower means smoother/more latency
    const INTERP_FACTOR = 0.5; // Aggressive setting for real-time feel
    const DEFAULT_STICKMAN_HEIGHT = 60; // Crucial for drawing remote players

    
    // Using the project ID from the config for the public data path
    const PROJECT_ID = CONFIG.projectId;
    const PLAYER_COLLECTION_PATH = `/artifacts/${PROJECT_ID}/public/data/players`;

    // Visual Effect Arrays
    let damageTexts = []; // To store floating damage numbers
    let attackEffects = []; // To store muzzle flashes and sword slashes
    let hitParticles = []; // To store particle effects on hit

    // Static obstacles for the map (x, y, w, h, type)
    const obstacles = [
        // Tower Platform (Tower top is at y=300)
        {x: 550, y: 300, w: 100, h: 100, type: 'platform'}, 
        // Wall/Stone structure
        {x: 100, y: 300, w: 50, h: 100, type: 'wall'}, 
        // Small Stone (low obstacle)
        {x: 250, y: 370, w: 30, h: 30, type: 'wall'},
        // Low cover (bushes/grass)
        {x: 350, y: 380, w: 80, h: 20, type: 'bush'}, 
        // Tree (non-colliding visually for atmosphere)
        {x: 60, y: 300, w: 20, h: 100, type: 'tree'},
        {x: 700, y: 320, w: 20, h: 80, type: 'tree'},
    ];


    // --- GAME STATE ---
    let keys = {};
    let bullets = [];
    let gameActive = true; 
    let isGameReady = false; // Flag for when Firebase and Auth are ready

    // --- UTILITY FUNCTIONS ---
    function showMessage(text, duration = 2000) {
        messageBox.textContent = text;
        setTimeout(() => {
            if (messageBox.textContent === text) {
                messageBox.textContent = '';
            }
        }, duration);
    }

    function setCanvasSize() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        const targetHeight = containerWidth * (427 / 760); 

        canvas.width = 760;
        canvas.height = 427; 
        
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = targetHeight + 'px';
    }

    // --- FIREBASE AUTH & DB SETUP ---

    async function initializeFirebase() {
        if (!CONFIG) {
            userStatus.textContent = 'Error: Firebase config missing.';
            return;
        }

        app = initializeApp(CONFIG);
        auth = getAuth(app);
        db = getFirestore(app);
        
        // Ensure the Google sign-in button is always visible until auth state is known
        userStatus.textContent = 'Please sign in to join the war.';
        googleSignInBtn.style.display = 'block';


        // onAuthStateChanged listener setup must happen after auth object is initialized
        onAuthStateChanged(auth, (user) => {
            if (user) {
                localPlayerId = user.uid;
                
                // Check if user is anonymous or has display name (Gmail user)
                const displayName = user.email || 'Warrior ' + user.uid.substring(0, 5); // Use a temporary name if needed
                const playerColor = localStorage.getItem(`playerColor_${localPlayerId}`) || getRandomColor();
                localStorage.setItem(`playerColor_${localPlayerId}`, playerColor);

                userStatus.textContent = `Welcome, ${displayName.split('@')[0]}.`;
                playerInfoDiv.innerHTML = `<span style="color: ${playerColor}; font-weight: bold;">[${displayName.split('@')[0]}]</span> | ID: ${localPlayerId.substring(0, 8)}...`;
                playerInfoDiv.style.display = 'block';
                // Hide Google sign-in button once authenticated
                googleSignInBtn.style.display = 'none';
                
                if (!isGameReady) {
                    isGameReady = true;
                    // Initialize local player state in the game object
                    localPlayer = new Stickman(canvas.width / 2, playerColor, localPlayerId, displayName);
                    // Register player in Firestore and start listening for all players
                    registerPlayerInFirestore();
                    listenForPlayers();
                    startKeepAlive(); 
                    
                    // Start the game loop after everything is initialized
                    if (!window.gameLoopStarted) {
                        window.gameLoopStarted = true;
                        requestAnimationFrame(loop);
                    }
                } else {
                    // Update local player state if they change auth methods (e.g., anon to Google)
                    localPlayer.id = localPlayerId;
                    localPlayer.color = playerColor;
                    localPlayer.name = displayName;
                    // Send minimal state update on re-auth
                    setDoc(doc(db, PLAYER_COLLECTION_PATH, localPlayerId), {
                        name: localPlayer.name,
                        color: localPlayer.color,
                        lastUpdated: Date.now()
                    }, { merge: true }).catch(e => console.warn("Player profile update failed:", e));
                }


            } else {
                localPlayerId = null;
                localPlayer = null;
                isGameReady = false;
                userStatus.textContent = 'Signed out. Sign in to join the war.';
                playerInfoDiv.style.display = 'none';
                googleSignInBtn.style.display = 'block';
                remotePlayers = {};
                stopKeepAlive(); 
            }
        });
    }

    function handleGoogleSignIn() {
        const provider = new GoogleAuthProvider();
        signInWithPopup(auth, provider)
            .then((result) => {
                // User signed in. onAuthStateChanged handles the rest.
                console.log("Google Sign-In successful:", result.user.uid);
            })
            .catch((error) => {
                console.error("Google Sign-In failed:", error.code, error.message);
                showMessage('Google sign-in failed. Try again.', 3000);
            });
    }

    // --- KEEP-ALIVE MECHANISM ---

    function startKeepAlive() {
        if (keepAliveInterval) clearInterval(keepAliveInterval);
        
        // Update the lastUpdated timestamp every 2 seconds if the player is not moving
        keepAliveInterval = setInterval(sendKeepAlive, 2000); 
    }

    function stopKeepAlive() {
        if (keepAliveInterval) {
            clearInterval(keepAliveInterval);
            keepAliveInterval = null;
        }
    }

    function sendKeepAlive() {
        if (!db || !localPlayer || !localPlayerId) return;

        // This ensures the timestamp is updated even when idle.
        const playerRef = doc(db, PLAYER_COLLECTION_PATH, localPlayerId);
        setDoc(playerRef, {
            lastUpdated: Date.now(),
        }, { merge: true }).catch(e => console.warn("Keep-alive failed:", e));
    }


    // --- FIREBASE DATA OPERATIONS ---

    function getRandomColor() {
        const colors = ['#00f2e0', '#f20050', '#ffeb3b', '#00e676', '#a933ff', '#ff8a00'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    async function registerPlayerInFirestore() {
        if (!db || !localPlayer) return;

        const playerRef = doc(db, PLAYER_COLLECTION_PATH, localPlayerId);
        
        // Ensure the initial Y position places the player directly on the ground (FLOOR).
        const initialY = FLOOR; 

        const initialPlayerState = {
            id: localPlayerId,
            name: localPlayer.name,
            color: localPlayer.color,
            x: canvas.width / 2 + Math.random() * 100 - 50, // slight random spawn offset
            y: initialY, // Set Y to the ground constant
            vx: 0,
            vy: 0,
            health: 100,
            isCrouching: false,
            isAttacking: false,
            facing: 'right',
            height: DEFAULT_STICKMAN_HEIGHT, // Include height explicitly
            lastUpdated: Date.now(),
            hitEffectTime: 0, 
            lastHealth: 100, // New field to track health changes for damage numbers
        };

        try {
            // Use setDoc to register the player with full profile and initial state
            await setDoc(playerRef, initialPlayerState, { merge: true });
            console.log("Player registered/updated:", localPlayerId);
            showMessage('Connected to the Arena! Fight!', 2000);
        } catch (e) {
            console.error("Error writing document:", e);
            showMessage('Error joining game.', 3000);
        }
    }
    
    // Function to update local player state to Firestore (minimal update)
    function updatePlayerInFirestore(player) {
        if (!db || !player) return;

        const playerRef = doc(db, PLAYER_COLLECTION_PATH, player.id);
        // Only send essential state data for real-time synchronization
        setDoc(playerRef, {
            x: player.x,
            y: player.y,
            vx: player.vx,
            vy: player.vy,
            health: player.health,
            isCrouching: player.isCrouching,
            isAttacking: player.isAttacking,
            facing: player.facing,
            height: player.height, 
            lastUpdated: Date.now(),
            hitEffectTime: player.hitEffectTime || 0, 
            lastHealth: player.lastHealth, // Send last health for damage calc
        }, { merge: true }).catch(e => console.warn("Sync failed:", e));
    }

    function listenForPlayers() {
        if (!db) return;

        const playersColRef = collection(db, PLAYER_COLLECTION_PATH);
        
        onSnapshot(playersColRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                const playerId = data.id;

                if (change.type === "added" || change.type === "modified") {
                    
                    // --- Handle Damage/Floating Numbers (Local Player) ---
                    if (playerId === localPlayerId && localPlayer) {
                        const damageTaken = localPlayer.health - data.health;
                        if (damageTaken > 0) {
                            damageTexts.push(new DamageText(localPlayer.x, localPlayer.y - localPlayer.height - 10, damageTaken));
                            hitParticles.push(new HitParticle(localPlayer.x, localPlayer.y - localPlayer.height / 2, '#f20050')); // Red hit
                        }
                        // CRITICAL: Update local player's transient state (health, hit effects)
                        localPlayer.health = data.health;
                        localPlayer.hitEffectTime = data.hitEffectTime;
                        localPlayer.lastHealth = data.health;
                        return;
                    }
                    
                    // --- Handle Remote Player State ---
                    let currentState = remotePlayers[playerId];
                    const newData = { ...data };
                    
                    // Check for remote damage taken before merging (uses old health vs new)
                    if (currentState && currentState.health > newData.health) {
                        const damageTaken = currentState.health - newData.health;
                        // Use the interpolated/display position for the visual effect
                        damageTexts.push(new DamageText(currentState.displayX || newData.x, currentState.displayY || newData.y - currentState.height - 10, damageTaken));
                        hitParticles.push(new HitParticle(currentState.displayX || newData.x, currentState.displayY || newData.y - currentState.height / 2, '#f20050')); // Red hit
                    }
                    
                    // CRITICAL FIX: Ensure essential properties exist and merge incoming data cleanly
                    if (!currentState) {
                        // New player: Initialize display position to match authoritative position
                        currentState = {
                            x: newData.x, 
                            y: newData.y, 
                            displayX: newData.x, 
                            displayY: newData.y,
                            height: newData.height || DEFAULT_STICKMAN_HEIGHT,
                            lastHealth: newData.health || 100, // Initialize lastHealth
                        };
                    } else {
                        // Existing player: Merge new data and maintain existing displayX/Y properties
                        currentState = { 
                            ...currentState, 
                            ...newData,
                            // Ensure display properties are not overwritten by the merge
                            displayX: currentState.displayX !== undefined ? currentState.displayX : newData.x,
                            displayY: currentState.displayY !== undefined ? currentState.displayY : newData.y,
                        };
                    }
                    
                    // Update remote player state
                    remotePlayers[playerId] = currentState;
                }
                if (change.type === "removed") {
                    delete remotePlayers[playerId];
                }
            });
            console.log("Total warriors online:", Object.keys(remotePlayers).length + (localPlayer ? 1 : 0));
        });
    }

    async function applyDamageToRemotePlayer(targetId, damage) {
        if (!db || !isGameReady) { // <-- CRITICAL FIX: Ensure game is fully ready
            console.error("Database or game not ready for damage transaction.");
            return;
        }

        if (!PLAYER_COLLECTION_PATH || typeof PLAYER_COLLECTION_PATH !== 'string' || !targetId) {
             console.error("Invalid path segments for damage transaction."); // <-- This path should only be hit if constants are missing.
             return;
        }

        const targetRef = doc(db, PLAYER_COLLECTION_PATH, targetId);

        try {
            await runTransaction(db, async (transaction) => {
                const targetDoc = await transaction.get(targetRef);
                if (!targetDoc.exists()) {
                    throw "Target player does not exist!";
                }
                
                // Get authoritative health from the transaction read
                const currentHealth = targetDoc.data().health;
                if (currentHealth <= 0) return; // Already dead

                const newHealth = Math.max(0, currentHealth - damage);
                
                transaction.update(targetRef, { 
                    health: newHealth,
                    hitEffectTime: Date.now(), // Set hit effect time on target
                    lastHealth: currentHealth, // Store old health for the remote client to calculate damage
                });

                if (newHealth === 0) {
                    showMessage(`${localPlayer.name.split('@')[0]} defeated ${targetDoc.data().name.split('@')[0]}!`, 5000);
                }
            });
        } catch (e) {
            console.warn("Damage transaction failed (likely concurrency issue, retrying internally):", e);
        }
    }


    // --- VISUAL EFFECT CLASSES ---

    class DamageText {
        constructor(x, y, damage) {
            this.x = x;
            this.y = y;
            this.text = `-${damage}`;
            this.life = 60; // Frames
            this.color = damage >= 15 ? '#ffeb3b' : '#ff1744'; // Crit damage or normal
        }

        update() {
            this.y -= 0.5; // Float up
            this.life--;
            return this.life <= 0; // Mark for removal
        }

        draw() {
            ctx.font = `${10 + (60 - this.life) * 0.1}px Inter`; // Grow slightly
            ctx.textAlign = 'center';
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 60; // Fade out
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0; // Reset alpha
        }
    }

    class HitParticle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2 - 1; // Slight upward bias
            this.life = 30; // Frames
            this.color = color; // e.g., '#f20050' for red blood
            this.radius = 2 + Math.random() * 2;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.05; // Gravity
            this.life--;
            return this.life <= 0;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 30;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class AttackEffect {
        constructor(x, y, type, facing) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.facing = facing;
            this.life = 10; // Frames (very quick flash)
        }

        update() {
            this.life--;
            return this.life <= 0;
        }

        draw() {
            const dir = this.facing === 'right' ? 1 : -1;
            ctx.globalAlpha = this.life / 10;
            ctx.shadowBlur = 10;

            if (this.type === 'muzzle') {
                // Muzzle Flash (Neon Yellow/Orange)
                ctx.fillStyle = '#ffc107';
                ctx.shadowColor = '#ffeb3b';
                const flashSize = 10;
                ctx.beginPath();
                ctx.arc(this.x + dir * 15, this.y, flashSize, 0, Math.PI * 2);
                ctx.fill();

            } else if (this.type === 'slash') {
                // Sword Slash (Neon Cyan Trail)
                ctx.strokeStyle = '#00f2e0';
                ctx.shadowColor = '#00f2e0';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x + dir * 30, this.y, 25, 
                    this.facing === 'right' ? Math.PI * 0.5 : Math.PI * 1.5, 
                    this.facing === 'right' ? Math.PI * 1.5 : Math.PI * 0.5);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1.0;
        }
    }


    // --- STICKMAN CLASS (Re-purposed for local player control and remote drawing) ---
    class Stickman {
        constructor(x, color, id, name) {
            this.id = id;
            this.name = name;
            this.x = x;
            this.y = FLOOR;
            this.vx = 0;
            this.vy = 0;
            this.width = 15;
            this.height = DEFAULT_STICKMAN_HEIGHT;
            this.color = color;
            this.health = 100;
            this.isJumping = false;
            this.isCrouching = false;
            this.isAttacking = false;
            this.facing = 'right';
            this.lastAttackTime = 0;
            this.weapon = 'sword'; 
            this.hitEffectTime = 0; // Local property for the visual effect
            this.lastHealth = 100; // Local health for sending to Firestore
            
            // For smooth remote drawing
            this.displayX = x; 
            this.displayY = FLOOR;
        }

        // Method to update this local player's state based on input
        handleInput() {
            if (this.health <= 0) return;

            let moved = false;
            let jumped = false;
            let attacked = false;
            
            // Store previous state for comparison
            const wasCrouching = this.isCrouching;
            const wasAttacking = this.isAttacking;
            
            this.isCrouching = false;
            this.isAttacking = false;

            if (keys['a']) {
                this.vx = -MOVE_SPEED;
                this.facing = 'left';
                moved = true;
            }
            if (keys['d']) {
                this.vx = MOVE_SPEED;
                this.facing = 'right';
                moved = true;
            }
            if (!moved) this.vx = 0;

            if (keys['s']) {
                this.isCrouching = true;
            }
            if (keys['w'] && !this.isJumping) {
                this.vy = JUMP_VELOCITY;
                this.isJumping = true;
                jumped = true;
            }
            
            // Sword Attack
            if (keys['f'] && Date.now() > this.lastAttackTime + COOLDOWN_TIME) {
                this.lastAttackTime = Date.now();
                this.isAttacking = true;
                attacked = true;
                // Add visual slash effect
                attackEffects.push(new AttackEffect(this.x, this.y - this.height / 2, 'slash', this.facing));
            }
            
            // Gun Attack (Firing a bullet)
            if (keys['g'] && Date.now() > this.lastAttackTime + 2 * COOLDOWN_TIME) {
                 this.lastAttackTime = Date.now();
                 this.fireGun();
                 attacked = true;
                 // Add visual muzzle effect
                 attackEffects.push(new AttackEffect(this.x, this.y - this.height / 2, 'muzzle', this.facing));
            }

            // CRITICAL FIX: Update Firestore if any movement or action occurred 
            if (moved || jumped || attacked || this.isCrouching !== wasCrouching || this.isAttacking !== wasAttacking) {
                updatePlayerInFirestore(this);
            }
        }
        
        // Method to draw any player (local or remote)
        draw(state = this) {
            // Player is dead
            if (state.health <= 0) return;

            // --- INTERPOLATION STEP (Only for remote players) ---
            let drawX = state.x;
            let drawY = state.y;
            let currentHeight = state.height || DEFAULT_STICKMAN_HEIGHT; // Defensive height check
            
            if (state.id !== localPlayerId) {
                // CRITICAL: Ensure display coords exist before trying to read them
                if (state.displayX === undefined || state.displayY === undefined) {
                    state.displayX = state.x;
                    state.displayY = state.y;
                }
                
                // Interpolate display position towards authoritative position (x, y)
                state.displayX += (state.x - state.displayX) * INTERP_FACTOR;
                state.displayY += (state.y - state.displayY) * INTERP_FACTOR;
                
                drawX = state.displayX;
                drawY = state.displayY;

            } else {
                // Local player should use their true position
                drawX = state.x;
                drawY = state.y;
            }
            // --- END INTERPOLATION STEP ---


            // Determine drawing color based on hit effect
            const isFlashing = Date.now() - state.hitEffectTime < HIT_FLASH_DURATION;
            const drawColor = isFlashing ? '#ff0000' : state.color; // Flash red on hit
            
            const bodyHeight = state.isCrouching ? currentHeight * 0.7 : currentHeight;
            const headRadius = 8;
            const legSeparation = 10;
            const bodyFloorY = drawY; // The Y coordinate is the floor level for the feet/base

            // 1. Draw Health Bar
            ctx.fillStyle = '#444';
            const barWidth = 60;
            const barHeight = 6;
            const barX = drawX - barWidth / 2;
            const barY = bodyFloorY - bodyHeight - 20; 
            
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const healthRatio = state.health / 100;
            ctx.fillStyle = healthRatio > 0.3 ? '#00e676' : '#ff1744';
            ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

            ctx.strokeStyle = '#fff';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // 2. Draw Name/ID
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = drawColor;
            
            // --- FIX: Safely access name before splitting ---
            const playerName = state.name || 'Unknown Warrior';
            ctx.fillText(playerName.split('@')[0], drawX, barY - 5);
            // --------------------------------------------------
            
            // 3. Draw Stickman Body
            
            // Head (Circle)
            const headY = bodyFloorY - bodyHeight + headRadius; 
            ctx.beginPath();
            ctx.arc(drawX, headY, headRadius, 0, Math.PI * 2); 
            ctx.fillStyle = drawColor;
            ctx.fill();
            ctx.closePath();

            // Body (Line)
            const bodyEnd = bodyFloorY - 15; 
            const bodyStart = headY + headRadius;
            
            ctx.strokeStyle = drawColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(drawX, bodyStart);
            ctx.lineTo(drawX, bodyEnd); 
            ctx.stroke();

            // Arms (Lines)
            let armOffset = state.isAttacking ? 10 : 0;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(drawX, bodyStart + 10);
            ctx.lineTo(drawX + legSeparation + armOffset, bodyStart + 20);
            ctx.stroke();

            // Right arm
            ctx.beginPath();
            ctx.moveTo(drawX, bodyStart + 10);
            ctx.lineTo(drawX - legSeparation - armOffset, bodyStart + 20);
            ctx.stroke();

            // Legs (Lines)
            // Legs start where body ends, and end at the floor (bodyFloorY)
            ctx.beginPath();
            ctx.moveTo(drawX, bodyEnd); 
            ctx.lineTo(drawX - legSeparation, bodyFloorY); 
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(drawX, bodyEnd);
            ctx.lineTo(drawX + legSeparation, bodyFloorY);
            ctx.stroke();


            // 4. Draw Weapon
            if (state.isAttacking) {
                this.drawSword(state, drawColor, drawX, bodyFloorY);
            } else {
                 this.drawGun(state, drawColor, drawX, bodyFloorY);
            }
        }

        drawSword(state, drawColor, drawX, bodyFloorY) {
            const swordLength = 50;
            const handleLength = 10;
            const bladeWidth = 4;
            const dir = state.facing === 'right' ? 1 : -1;
            const armX = drawX + dir * 10;
            const armY = bodyFloorY - state.height / 2; // Mid-body height
            
            // 1. Draw Hilt (Handle/Grip) - Dark metal color
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(armX, armY);
            ctx.lineTo(armX + dir * handleLength, armY);
            ctx.stroke();

            // 2. Draw Blade - Neon Cyan Glow
            // Shadow/Glow effect (Subtle light trail)
            ctx.lineWidth = bladeWidth + 2; 
            ctx.strokeStyle = 'rgba(0, 242, 224, 0.7)'; 
            ctx.shadowColor = 'rgba(0, 242, 224, 1)';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(armX + dir * handleLength, armY);
            ctx.lineTo(armX + dir * (handleLength + swordLength), armY);
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow

            // 3. Draw the solid blade line (Bright edge)
            ctx.strokeStyle = drawColor; // Use drawColor (color or red flash)
            ctx.lineWidth = bladeWidth;
            ctx.beginPath();
            ctx.moveTo(armX + dir * handleLength, armY);
            ctx.lineTo(armX + dir * (handleLength + swordLength), armY);
            ctx.stroke();
        }
        
        drawGun(state, drawColor, drawX, bodyFloorY) {
            const dir = state.facing === 'right' ? 1 : -1;
            const centerX = drawX + dir * 10;
            const gunY = bodyFloorY - state.height / 2; // Mid-body height
            
            const gripHeight = 15;
            const gripWidth = 5;
            const bodyLength = 20;
            const bodyHeight = 7;
            const barrelLength = 5;

            // 1. Draw Grip/Handle (vertical part) - Darker material
            ctx.fillStyle = '#111'; 
            const gripX = centerX + dir * 2;
            ctx.fillRect(gripX - gripWidth / 2, gunY, gripWidth, gripHeight);
            
            // 2. Draw Body/Slide (horizontal part) - Dark metal
            ctx.fillStyle = '#333'; 
            const bodyX = centerX + dir * 2;
            ctx.fillRect(bodyX + dir * 2, gunY - bodyHeight / 2, bodyLength, bodyHeight);

            // 3. Draw Barrel Tip (Neon Pink Accent)
            ctx.fillStyle = '#f20050'; 
            ctx.fillRect(bodyX + dir * (bodyLength + 2), gunY - 2, barrelLength, 4); 
            
            // 4. Draw Grip Outline for definition
            ctx.strokeStyle = drawColor; // Use drawColor (color or red flash)
            ctx.lineWidth = 1;
            ctx.strokeRect(gripX - gripWidth / 2, gunY, gripWidth, gripHeight);
        }

        checkPlatformCollision() {
            let isColliding = false;

            // Iterate over all obstacles to check for landing
            for (const obs of obstacles) {
                // Only platforms and walls can be landed on
                if (obs.type === 'platform' || obs.type === 'wall' || obs.type === 'bush') {
                    
                    // Check horizontal overlap
                    // Broadened horizontal check slightly
                    const horizontalOverlap = this.x >= obs.x - this.width/2 && this.x <= (obs.x + obs.w + this.width/2);

                    // Check if player is falling onto the platform top
                    const isFallingOnto = this.y < obs.y && this.y + this.vy >= obs.y;

                    if (horizontalOverlap && isFallingOnto) {
                        this.y = obs.y; // Set position to platform top
                        this.vy = 0;
                        this.isJumping = false;
                        isColliding = true;
                        break; // Found a platform, stop checking
                    }
                }
            }

            // Apply gravity/floor check only if not on an obstacle
            if (!isColliding) {
                // 1. Apply Physics (Gravity) to local player
                this.vy += GRAVITY;
                this.y += this.vy;

                // 2. Main Floor Collision
                if (this.y > FLOOR) {
                    this.y = FLOOR;
                    this.vy = 0;
                    this.isJumping = false;
                }
            } else if (this.y > FLOOR) {
                 // Check if the player fell off a platform onto the main floor
                this.y = FLOOR;
                this.vy = 0;
                this.isJumping = false;
            }

            return isColliding || this.y === FLOOR;
        }

        update() {
            if (this.health <= 0) return;
            
            // 1. Handle Physics and Platform Collision
            this.checkPlatformCollision();

            // 2. Apply Movement
            this.x += this.vx;

            // 3. Boundary Check
            if (this.x < this.width / 2) this.x = this.width / 2;
            if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
            
            // 4. Check for attack end (local client only)
            if (Date.now() - this.lastAttackTime > 150 && this.isAttacking) {
                this.isAttacking = false;
                updatePlayerInFirestore(this);
            }
            
            // 5. Check for hits on *remote* players (Client-side hit detection)
            this.checkMeleeHit();
        }
        
        fireGun() {
            const bulletSpeed = 10;
            const bulletVel = this.facing === 'right' ? bulletSpeed : -bulletSpeed;
            
            // Bullets are local to the shooter's screen to avoid heavy Firestore traffic
            const bullet = new Bullet(
                this.x + (this.facing === 'right' ? 20 : -20), // Bullet starts near the barrel
                this.y - this.height / 2, // Mid-body height
                bulletVel, 
                this.id
            );
            bullets.push(bullet);
        }

        checkMeleeHit() {
            if (!this.isAttacking || !isGameReady) return; // <-- Check game readiness here

            // Melee hitbox check
            const swordTipX = this.x + (this.facing === 'right' ? 60 : -60); // Sword tip is ~60 units away
            const swordTipY = this.y - this.height / 2; // Sword vertical position (mid-body)

            // Check against all remote players
            Object.values(remotePlayers).forEach(remoteState => {
                if (remoteState.health <= 0) return;

                // --- CRITICAL: Check against the local player's ID --
                if (remoteState.id === localPlayerId) return;

                // --- Use the authoritative state (x, y) for hit detection ---
                const targetCenterX = remoteState.x;
                const targetHeight = remoteState.height || DEFAULT_STICKMAN_HEIGHT;
                const targetCenterY = remoteState.y - targetHeight / 2; 
                
                // Distance check between sword tip and remote player center
                const dx = targetCenterX - swordTipX;
                const dy = targetCenterY - swordTipY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 30) { // Hitbox radius
                    // Hit detected! Apply damage via Firestore transaction
                    applyDamageToRemotePlayer(remoteState.id, 10); // Sword damage
                    this.isAttacking = false; // End attack immediately after hit
                    updatePlayerInFirestore(this);
                }
            });
        }
    }

    // --- BULLET CLASS (Local to the shooter, only reports damage) ---
    class Bullet {
        constructor(x, y, vx, ownerId) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.radius = 4;
            this.color = '#ffeb3b'; 
            this.ownerId = ownerId;
            this.damage = 15;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            if (!isGameReady) return false; // <-- Check game readiness here

            this.x += this.vx;

            // Check hit against all remote players
            let hit = false;
            Object.values(remotePlayers).forEach(remoteState => {
                if (remoteState.health <= 0) return;
                
                // --- CRITICAL: Check against the local player's ID --
                if (remoteState.id === localPlayerId) return;
                
                // --- Use the authoritative state (x, y) for bullet hit detection ---
                // Ensure remoteState.height is available, defaulting if necessary
                const targetHeight = remoteState.height || DEFAULT_STICKMAN_HEIGHT;
                
                const playerBodyTop = remoteState.y - targetHeight;
                const playerBodyBottom = remoteState.y;
                const playerLeft = remoteState.x - remoteState.width / 2;
                const playerRight = remoteState.x + remoteState.width / 2;

                if (this.x > playerLeft && this.x < playerRight &&
                    this.y > playerBodyTop && this.y < playerBodyBottom) {
                        
                    // Only apply damage if the owner of the bullet is not the target
                    if (this.ownerId !== remoteState.id) {
                        applyDamageToRemotePlayer(remoteState.id, this.damage);
                        hit = true; 
                    }
                }
            });

            // Out of bounds or hit
            if (this.x < -10 || this.x > canvas.width + 10 || hit) {
                return true; // Mark for deletion
            }
            return false; // Keep bullet active
        }
    }

    function drawObstacles() {
        obstacles.forEach(obs => {
            if (obs.type === 'platform') {
                // Tower Base (Dark metal)
                ctx.fillStyle = '#333';
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                // Tower Top (Neon accent)
                ctx.fillStyle = '#00f2e0';
                ctx.fillRect(obs.x, obs.y, obs.w, 5);

            } else if (obs.type === 'wall') {
                // Wall/Stone (Mossy gray)
                ctx.fillStyle = '#444'; 
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                // Stone texture/shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h * 0.2); 

            } else if (obs.type === 'bush') {
                // Low Cover/Grass (Dark Green Neon)
                ctx.fillStyle = '#006400';
                ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                // Sharp grass outline
                ctx.fillStyle = '#00e676';
                ctx.beginPath();
                for (let i = 0; i < obs.w; i += 5) {
                    ctx.moveTo(obs.x + i, obs.y);
                    ctx.lineTo(obs.x + i + 2.5, obs.y - 10);
                    ctx.lineTo(obs.x + i + 5, obs.y);
                }
                ctx.fill();
            } else if (obs.type === 'tree') {
                 // Tree Trunk
                ctx.fillStyle = '#4e342e'; // Brown
                ctx.fillRect(obs.x + obs.w/2 - 5, obs.y, 10, obs.h);
                
                // Tree Canopy (Neon Green)
                ctx.fillStyle = '#00cc00';
                ctx.beginPath();
                ctx.arc(obs.x + obs.w/2, obs.y, obs.w * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }


    // --- GAME LOOP & RENDERING ---
    function update() {
        if (!isGameReady || !localPlayer) return;

        // 1. Handle Input & Update Local Physics
        localPlayer.handleInput();
        localPlayer.update(); // Apply local physics (gravity, movement)
        
        // 2. Update Visual Effects
        damageTexts = damageTexts.filter(text => !text.update());
        attackEffects = attackEffects.filter(effect => !effect.update());
        hitParticles = hitParticles.filter(particle => !particle.update());
        
        // 3. Update Bullets (local only)
        bullets = bullets.filter(bullet => !bullet.update());
        
        // 4. Remote Player cleanup (if player hasn't updated in 30 seconds, assume disconnect)
        const now = Date.now();
        for (const id in remotePlayers) {
            // INCREASED TIMEOUT: Now 30 seconds (30000ms) to prevent quick removal
            if (now - remotePlayers[id].lastUpdated > 30000) { 
                console.log(`Removing inactive warrior: ${remotePlayers[id].name}`);
                delete remotePlayers[id];
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Ground
        ctx.fillStyle = '#4a007d'; 
        ctx.fillRect(0, FLOOR, canvas.width, canvas.height - FLOOR);

        if (isGameReady) {
            // Draw Obstacles before players
            drawObstacles();

            // Draw all remote players based on their synchronized state
            Object.values(remotePlayers).forEach(remoteState => {
                // >>>>>> CRITICAL FIX: Skip drawing if this is the local player <<<<<<
                if (remoteState.id === localPlayerId) return; 

                // FIX: Draw remote player directly using its state object for interpolation continuity
                // No need to instantiate a new Stickman object here; the state object holds the necessary properties.
                Stickman.prototype.draw.call(remoteState, remoteState);
            });

            // Draw Local Player last (on top)
            if (localPlayer) {
                localPlayer.draw();
            }

            // Draw Local Bullets
            bullets.forEach(bullet => bullet.draw());
            
            // Draw Visual Effects on top of everything
            attackEffects.forEach(effect => effect.draw());
            hitParticles.forEach(particle => particle.draw());
            damageTexts.forEach(text => text.draw());
            
            // Show player count
             ctx.font = '14px Inter';
             ctx.textAlign = 'right';
             ctx.fillStyle = '#ffffff';
             ctx.fillText(`Warriors Online: ${Object.keys(remotePlayers).length + (localPlayer ? 1 : 0)}`, canvas.width - 10, 20);
        } else {
             ctx.font = '24px Inter';
             ctx.textAlign = 'center';
             ctx.fillStyle = '#ffffff';
             ctx.fillText('LOADING ARENA...', canvas.width / 2, canvas.height / 2);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- INPUT HANDLERS ---
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = true;
        
        // Prevent default actions for control keys
        if (['a', 'd', 'w', 's', 'f', 'g'].includes(key)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // --- EVENT LISTENERS ---
    window.addEventListener('load', () => {
        setCanvasSize();
        initializeFirebase();
        googleSignInBtn.addEventListener('click', handleGoogleSignIn);
    });
    window.addEventListener('resize', setCanvasSize);
    
    // --- Graceful Disconnect on tab close/refresh ---
    window.addEventListener('beforeunload', async () => {
        if (localPlayerId && db) {
            const playerRef = doc(db, PLAYER_COLLECTION_PATH, localPlayerId);
            // Mark the player as effectively inactive/dead on disconnect
            await setDoc(playerRef, { health: 0, lastUpdated: Date.now() }, { merge: true });
        }
    });

</script>

</body>
</html>
