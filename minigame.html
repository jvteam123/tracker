<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Stick War Arena | Neon Combat</title>
    <!-- Using Inter font from Google Fonts and Tailwind for utility styling -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* Custom CSS for a cool, professional game aesthetic */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #100f2e 0%, #08081a 100%); /* Deep space gradient */
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better screen usage */
            min-height: 100vh;
            margin: 0;
            padding: 20px 10px;
            overflow-y: auto;
        }

        .game-container {
            background-color: #1c1c3f; /* Darker, sophisticated base */
            border: 2px solid #00f2e0; /* Neon cyan primary border */
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(0, 242, 224, 0.2), 0 0 60px rgba(242, 0, 80, 0.1); /* Subtle dual glow */
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 900px;
        }

        h1 {
            color: #ffeb3b; /* Vibrant gold text for title */
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.6);
            margin-bottom: 20px;
            font-size: 2.5em;
            font-weight: 900;
            letter-spacing: 2px;
        }

        #gameCanvas {
            border: 4px solid #f20050; /* Neon pink accent border */
            background-color: #0d0d1a;
            border-radius: 12px;
            touch-action: none; 
            width: 100%; 
            max-width: 860px;
            aspect-ratio: 16 / 9; 
            box-shadow: 0 0 15px rgba(242, 0, 80, 0.5);
        }

        /* Sleek Info Bar Styling */
        .info-bar-item {
            padding: 8px 16px;
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 242, 224, 0.4);
            font-size: 0.8rem;
            text-shadow: 0 0 5px rgba(0, 242, 224, 0.5);
        }

        /* Professional Button Styling */
        #google-signin-btn {
            background: linear-gradient(90deg, #4285f4, #2a73e8);
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.5);
            transition: all 0.2s ease-in-out;
        }
        #google-signin-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.7);
        }

        /* Controls Section Styling */
        .controls {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            width: 100%;
            max-width: 860px;
            border-top: 1px solid #00f2e0;
        }

        .controls table {
            font-size: 0.85em;
        }

        .controls th {
            color: #ffeb3b;
        }

        .controls td {
            color: #b3e5fc; /* Light blue for key names */
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            padding: 5px 8px;
            font-family: monospace;
            text-transform: uppercase;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            .info-bar {
                flex-direction: column;
                gap: 8px;
            }
            .info-bar-item {
                font-size: 0.75rem;
                padding: 6px 10px;
            }
            .controls table {
                font-size: 0.75em;
            }
        }
    </style>
</head>
<body>

<div class="game-container">
    <h1 class="text-3xl">ONLINE STICK WAR ARENA</h1>
    
    <!-- AUTHENTICATION & INFO BAR (Sleek, horizontal UI) -->
    <div id="auth-ui" class="info-bar flex justify-between items-center w-full max-w-lg mb-4 p-2">
        <div id="player-info" class="info-bar-item break-all" style="display:none;"></div>

        <!-- Status & Sign-in container -->
        <div class="flex flex-col items-end sm:flex-row sm:items-center gap-3">
             <p id="user-status" class="text-sm text-yellow-300">Initializing...</p>
             <button id="google-signin-btn" class="font-bold py-2 px-4 rounded-lg shadow-lg" style="display:none;">
                 Sign in with Gmail
             </button>
        </div>
    </div>
    
    <!-- GAME SECTION -->
    <canvas id="gameCanvas" width="760" height="427"></canvas>
    
    <div id="message-box" class="mt-4 h-8 text-lg font-bold text-center text-red-500 shadow-sm"></div>

    <div class="controls">
        <h2 class="text-xl font-bold text-center mb-4" style="color:#00f2e0;">GLOBAL COMMANDS</h2>
        <table class="w-full text-left">
            <thead>
                <tr>
                    <th class="w-1/3">ACTION</th>
                    <th class="w-2/3">KEY</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Movement</td>
                    <td>A (Left) / D (Right)</td>
                </tr>
                <tr>
                    <td>Jump</td>
                    <td>W</td>
                </tr>
                <tr>
                    <td>Crouch (Hold)</td>
                    <td>S</td>
                </tr>
                <tr>
                    <td>**SWORD ATTACK** (Melee)</td>
                    <td>F</td>
                </tr>
                <tr>
                    <td>**GUN FIRE** (Ranged)</td>
                    <td>G</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script type="module">
    // --- FIREBASE IMPORTS ---
    // Note: The imports use the stable Firebase 11.6.1 version.
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Set Firestore log level to debug for development
    setLogLevel('Debug');

    // --- FIREBASE CONFIGURATION (Hardcoded with user's provided data) ---
    const CONFIG = {
        apiKey: "AIzaSyDVWkdPgYRUK9RZl6enJGmqLXl5wrISt7M",
        authDomain: "minigame-3ea0a.firebaseapp.com",
        projectId: "minigame-3ea0a",
        storageBucket: "minigame-3ea0a.firebasestorage.app",
        messagingSenderId: "937404427991",
        appId: "1:937404427991:web:2bb29763acbe438f794a92"
    };

    let app, db, auth;
    let localPlayerId = null;
    let localPlayer = null;
    let remotePlayers = {}; // Dictionary to hold all remote player states
    
    // --- GAME INITIALIZATION ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageBox = document.getElementById('message-box');
    const googleSignInBtn = document.getElementById('google-signin-btn');
    const userStatus = document.getElementById('user-status');
    const playerInfoDiv = document.getElementById('player-info');
    
    // --- GAME CONSTANTS ---
    const GRAVITY = 0.5;
    const FLOOR = canvas.height - 40;
    const JUMP_VELOCITY = -12;
    const MOVE_SPEED = 4;
    const COOLDOWN_TIME = 300; // ms
    // Using the project ID from the config for the public data path
    const PROJECT_ID = CONFIG.projectId;
    const PLAYER_COLLECTION_PATH = `/artifacts/${PROJECT_ID}/public/data/players`;

    // --- GAME STATE ---
    let keys = {};
    let bullets = [];
    let gameActive = true; 
    let isGameReady = false; // Flag for when Firebase and Auth are ready

    // --- UTILITY FUNCTIONS ---
    function showMessage(text, duration = 2000) {
        messageBox.textContent = text;
        setTimeout(() => {
            if (messageBox.textContent === text) {
                messageBox.textContent = '';
            }
        }, duration);
    }

    function setCanvasSize() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth;
        const targetHeight = containerWidth * (427 / 760); 

        canvas.width = 760;
        canvas.height = 427; 
        
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = targetHeight + 'px';
    }

    // --- FIREBASE AUTH & DB SETUP ---

    async function initializeFirebase() {
        if (!CONFIG) {
            userStatus.textContent = 'Error: Firebase config missing.';
            return;
        }

        app = initializeApp(CONFIG);
        auth = getAuth(app);
        db = getFirestore(app);

        // Initial sign-in anonymously if no user is currently authenticated
        try {
            if (!auth.currentUser) {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Initial sign-in failed:", error);
            userStatus.textContent = 'Authentication Failed. Please sign in with Google.';
            googleSignInBtn.style.display = 'block';
        }
        
        // onAuthStateChanged listener setup must happen after auth object is initialized
        onAuthStateChanged(auth, (user) => {
            if (user) {
                localPlayerId = user.uid;
                
                // Check if user is anonymous or has display name (Gmail user)
                const displayName = user.email || 'Anonymous Warrior';
                const playerColor = localStorage.getItem(`playerColor_${localPlayerId}`) || getRandomColor();
                localStorage.setItem(`playerColor_${localPlayerId}`, playerColor);

                userStatus.textContent = `Welcome, ${displayName.split('@')[0]}.`;
                playerInfoDiv.innerHTML = `<span style="color: ${playerColor}; font-weight: bold;">[${displayName.split('@')[0]}]</span> | ID: ${localPlayerId.substring(0, 8)}...`;
                playerInfoDiv.style.display = 'block';
                // Show Google sign-in button if the user is currently anonymous
                googleSignInBtn.style.display = user.isAnonymous ? 'block' : 'none';
                
                if (!isGameReady) {
                    isGameReady = true;
                    // Initialize local player state in the game object
                    localPlayer = new Stickman(canvas.width / 2, playerColor, localPlayerId, displayName);
                    // Register player in Firestore and start listening for all players
                    registerPlayerInFirestore();
                    listenForPlayers();
                    
                    // Start the game loop after everything is initialized
                    if (!window.gameLoopStarted) {
                        window.gameLoopStarted = true;
                        requestAnimationFrame(loop);
                    }
                } else {
                    // Update local player state if they change auth methods (e.g., anon to Google)
                    localPlayer.id = localPlayerId;
                    localPlayer.color = playerColor;
                    localPlayer.name = displayName;
                    updatePlayerInFirestore(localPlayer);
                }


            } else {
                localPlayerId = null;
                localPlayer = null;
                isGameReady = false;
                userStatus.textContent = 'Signed out. Sign in to join the war.';
                playerInfoDiv.style.display = 'none';
                googleSignInBtn.style.display = 'block';
                remotePlayers = {};
            }
        });
    }

    function handleGoogleSignIn() {
        const provider = new GoogleAuthProvider();
        signInWithPopup(auth, provider)
            .then((result) => {
                // User signed in
                console.log("Google Sign-In successful:", result.user.uid);
            })
            .catch((error) => {
                console.error("Google Sign-In failed:", error.code, error.message);
                showMessage('Google sign-in failed. Try again.', 3000);
            });
    }

    // --- FIREBASE DATA OPERATIONS ---

    function getRandomColor() {
        const colors = ['#00f2e0', '#f20050', '#ffeb3b', '#00e676', '#a933ff', '#ff8a00'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    async function registerPlayerInFirestore() {
        if (!db || !localPlayer) return;

        const playerRef = doc(db, PLAYER_COLLECTION_PATH, localPlayerId);
        
        const initialPlayerState = {
            id: localPlayerId,
            name: localPlayer.name,
            color: localPlayer.color,
            x: canvas.width / 2 + Math.random() * 100 - 50, // slight random spawn offset
            y: FLOOR,
            vx: 0,
            vy: 0,
            health: 100,
            isCrouching: false,
            isAttacking: false,
            facing: 'right',
            lastUpdated: Date.now(),
            // Only non-transient data should be here
        };

        try {
            await setDoc(playerRef, initialPlayerState, { merge: true });
            console.log("Player registered/updated:", localPlayerId);
            showMessage('Connected to the Arena! Fight!', 2000);
        } catch (e) {
            console.error("Error writing document:", e);
            showMessage('Error joining game.', 3000);
        }
    }
    
    function updatePlayerInFirestore(player) {
        if (!db || !player) return;

        // Debounce or only update necessary fields for efficiency
        const playerRef = doc(db, PLAYER_COLLECTION_PATH, player.id);
        setDoc(playerRef, {
            x: player.x,
            y: player.y,
            vx: player.vx,
            vy: player.vy,
            health: player.health,
            isCrouching: player.isCrouching,
            isAttacking: player.isAttacking,
            facing: player.facing,
            lastUpdated: Date.now(),
        }, { merge: true }).catch(e => console.warn("Sync failed:", e));
    }

    function listenForPlayers() {
        if (!db) return;

        const playersColRef = collection(db, PLAYER_COLLECTION_PATH);
        
        onSnapshot(playersColRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                const playerId = data.id;

                if (playerId === localPlayerId) return; // Skip local player

                if (change.type === "added" || change.type === "modified") {
                    // Update or add remote player state
                    remotePlayers[playerId] = data;
                }
                if (change.type === "removed") {
                    delete remotePlayers[playerId];
                }
            });
            console.log("Total players online:", Object.keys(remotePlayers).length + (localPlayer ? 1 : 0));
        });
    }

    async function applyDamageToRemotePlayer(targetId, damage) {
        if (!db) return;
        const targetRef = doc(db, PLAYER_COLLECTION_PATH, targetId);

        try {
            await runTransaction(db, async (transaction) => {
                const targetDoc = await transaction.get(targetRef);
                if (!targetDoc.exists()) {
                    throw "Target player does not exist!";
                }

                const currentHealth = targetDoc.data().health;
                if (currentHealth <= 0) return; // Already dead

                const newHealth = Math.max(0, currentHealth - damage);
                
                transaction.update(targetRef, { 
                    health: newHealth,
                    // Optionally add hit feedback/effect state
                });

                if (newHealth === 0) {
                    showMessage(`${localPlayer.name.split('@')[0]} defeated ${targetDoc.data().name.split('@')[0]}!`, 5000);
                }
            });
        } catch (e) {
            console.error("Damage transaction failed:", e);
        }
    }


    // --- STICKMAN CLASS (Re-purposed for local player control and remote drawing) ---
    class Stickman {
        constructor(x, color, id, name) {
            this.id = id;
            this.name = name;
            this.x = x;
            this.y = FLOOR;
            this.vx = 0;
            this.vy = 0;
            this.width = 15;
            this.height = 60;
            this.color = color;
            this.health = 100;
            this.isJumping = false;
            this.isCrouching = false;
            this.isAttacking = false;
            this.facing = 'right';
            this.lastAttackTime = 0;
            this.weapon = 'sword'; 
        }

        // Method to update this local player's state based on input
        handleInput() {
            if (this.health <= 0) return;

            // Only track input; movement is applied in update()
            let moved = false;
            this.isCrouching = false;

            if (keys['a']) {
                this.vx = -MOVE_SPEED;
                this.facing = 'left';
                moved = true;
            }
            if (keys['d']) {
                this.vx = MOVE_SPEED;
                this.facing = 'right';
                moved = true;
            }
            if (!moved) this.vx = 0;

            if (keys['s']) {
                this.isCrouching = true;
            }
            if (keys['w'] && !this.isJumping) {
                this.vy = JUMP_VELOCITY;
                this.isJumping = true;
                updatePlayerInFirestore(this);
            }
            
            // Sword Attack
            if (keys['f'] && Date.now() > this.lastAttackTime + COOLDOWN_TIME) {
                this.lastAttackTime = Date.now();
                this.isAttacking = true;
                updatePlayerInFirestore(this);
            }
            
            // Gun Attack (Firing a bullet)
            if (keys['g'] && Date.now() > this.lastAttackTime + 2 * COOLDOWN_TIME) {
                 this.lastAttackTime = Date.now();
                 this.fireGun();
                 updatePlayerInFirestore(this); // Sync attack status
            }

            if (moved || this.isCrouching || this.isAttacking) {
                updatePlayerInFirestore(this);
            }
        }
        
        // Method to draw any player (local or remote)
        draw(state = this) {
            // Player is dead
            if (state.health <= 0) return;

            // 1. Draw Health Bar
            ctx.fillStyle = '#444';
            const barWidth = 60;
            const barHeight = 6;
            const barX = state.x - barWidth / 2;
            const barY = state.y - state.height - 20;
            
            ctx.fillRect(barX, barY, barWidth, barHeight);

            const healthRatio = state.health / 100;
            ctx.fillStyle = healthRatio > 0.3 ? '#00e676' : '#ff1744';
            ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

            ctx.strokeStyle = '#fff';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // 2. Draw Name/ID
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            ctx.fillStyle = state.color;
            ctx.fillText(state.name.split('@')[0], state.x, state.y - state.height - 25);
            ctx.fillStyle = state.color;


            // 3. Draw Stickman Body
            // Head (Circle)
            ctx.beginPath();
            ctx.arc(state.x, state.y - state.height - 10, 8, 0, Math.PI * 2);
            ctx.fillStyle = state.color;
            ctx.fill();
            ctx.closePath();

            // Body (Line)
            const bodyEnd = state.y - 10;
            const bodyStart = state.y - state.height;
            
            ctx.strokeStyle = state.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(state.x, bodyStart);
            ctx.lineTo(state.x, bodyEnd);
            ctx.stroke();

            // Arms (Lines)
            let armOffset = state.isAttacking ? 10 : 0;
            
            // Left arm
            ctx.beginPath();
            ctx.moveTo(state.x, bodyStart + 10);
            ctx.lineTo(state.x + 10 + armOffset, bodyStart + 20);
            ctx.stroke();

            // Right arm
            ctx.beginPath();
            ctx.moveTo(state.x, bodyStart + 10);
            ctx.lineTo(state.x - 10 - armOffset, bodyStart + 20);
            ctx.stroke();

            // Legs (Lines)
            ctx.beginPath();
            ctx.moveTo(state.x, bodyEnd);
            ctx.lineTo(state.x - 10, bodyEnd + (state.isCrouching ? 5 : 20));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(state.x, bodyEnd);
            ctx.lineTo(state.x + 10, bodyEnd + (state.isCrouching ? 5 : 20));
            ctx.stroke();


            // 4. Draw Weapon
            if (state.isAttacking) {
                // Draw Sword Swing if attacking
                this.drawSword(state);
            } else {
                 // Draw Gun in resting position
                this.drawGun(state);
            }
        }

        drawSword(state) {
            ctx.strokeStyle = '#00f2e0'; // Neon Cyan for the sword
            ctx.lineWidth = 5;

            const swordLength = 40;
            
            // Swinging the sword
            const swingStart = state.facing === 'right' ? Math.PI * 1.75 : Math.PI * 1.25;
            const swingEnd = state.facing === 'right' ? Math.PI * 0.25 : Math.PI * 0.75;

            ctx.beginPath();
            ctx.arc(state.x, state.y - 30, swordLength, swingStart, swingEnd);
            ctx.stroke();

            // Spark effect during swing
            ctx.fillStyle = '#ffeb3b';
            ctx.beginPath();
            ctx.arc(state.x + (state.facing === 'right' ? 30 : -30), state.y - 50, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        drawGun(state) {
            ctx.fillStyle = '#f20050'; // Neon Pink for the gun
            ctx.strokeStyle = '#f20050';
            ctx.lineWidth = 2;
            const barrelLength = 15;
            const gunY = state.y - 30;
            const gunX = state.x + (state.facing === 'right' ? 10 : -10); // Hold position
            const barrelTipX = gunX + (state.facing === 'right' ? 15 : -15);

            // Gun body (rectangle)
            ctx.fillRect(Math.min(gunX, barrelTipX), gunY - 3, Math.abs(barrelTipX - gunX), 6);
        }

        update() {
            if (this.health <= 0) return;
            
            // 1. Apply Physics (Gravity) to local player
            this.vy += GRAVITY;
            this.y += this.vy;

            // 2. Floor Collision
            if (this.y > FLOOR) {
                this.y = FLOOR;
                this.vy = 0;
                this.isJumping = false;
            }

            // 3. Apply Movement
            this.x += this.vx;

            // 4. Boundary Check
            if (this.x < this.width / 2) this.x = this.width / 2;
            if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
            
            // 5. Check for attack end (local client only)
            if (Date.now() - this.lastAttackTime > 150 && this.isAttacking) {
                this.isAttacking = false;
                updatePlayerInFirestore(this);
            }
            
            // 6. Check for hits on *remote* players (Client-side hit detection)
            this.checkMeleeHit();
        }
        
        fireGun() {
            const bulletSpeed = 10;
            const bulletVel = this.facing === 'right' ? bulletSpeed : -bulletSpeed;
            
            // Bullets are local to the shooter's screen to avoid heavy Firestore traffic
            const bullet = new Bullet(
                this.x + (this.facing === 'right' ? 10 : -10), 
                this.y - 30, 
                bulletVel, 
                this.id
            );
            bullets.push(bullet);
        }

        checkMeleeHit() {
            if (!this.isAttacking) return;
            
            const range = 50;
            const hitX = this.x + (this.facing === 'right' ? range : -range);
            const hitY = this.y - 30;
            
            // Check against all remote players
            Object.values(remotePlayers).forEach(remoteState => {
                if (remoteState.health <= 0) return;

                const dx = remoteState.x - hitX;
                const dy = remoteState.y - 30 - hitY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 30) {
                    // Hit detected! Apply damage via Firestore transaction
                    applyDamageToRemotePlayer(remoteState.id, 10); // Sword damage
                    this.isAttacking = false; // End attack immediately after hit
                    updatePlayerInFirestore(this);
                }
            });
        }
    }

    // --- BULLET CLASS (Local to the shooter, only reports damage) ---
    class Bullet {
        constructor(x, y, vx, ownerId) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.radius = 4;
            this.color = '#ffeb3b'; 
            this.ownerId = ownerId;
            this.damage = 15;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            this.x += this.vx;

            // Check hit against all remote players
            let hit = false;
            Object.values(remotePlayers).forEach(remoteState => {
                if (remoteState.health <= 0) return;
                
                // Simple distance check
                const dx = remoteState.x - this.x;
                const dy = (remoteState.y - 30) - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < remoteState.width + this.radius) {
                    if (this.ownerId !== remoteState.id) {
                        applyDamageToRemotePlayer(remoteState.id, this.damage);
                        hit = true; 
                    }
                }
            });

            // Out of bounds or hit
            if (this.x < -10 || this.x > canvas.width + 10 || hit) {
                return true; // Mark for deletion
            }
            return false; // Keep bullet active
        }
    }


    // --- GAME LOOP & RENDERING ---
    function update() {
        if (!isGameReady || !localPlayer) return;

        // 1. Handle Input & Update Local Physics
        localPlayer.handleInput();
        localPlayer.update(); // Apply local physics (gravity, movement)
        
        // 2. Update Bullets (local only)
        bullets = bullets.filter(bullet => !bullet.update());
        
        // 3. Remote Player cleanup (if player hasn't updated in 10 seconds, assume disconnect)
        const now = Date.now();
        for (const id in remotePlayers) {
            if (now - remotePlayers[id].lastUpdated > 10000) {
                delete remotePlayers[id];
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Ground
        ctx.fillStyle = '#4a007d'; 
        ctx.fillRect(0, FLOOR, canvas.width, canvas.height - FLOOR);

        if (isGameReady) {
            // Draw all remote players based on their synchronized state
            Object.values(remotePlayers).forEach(remoteState => {
                // Draw remote player using their state object
                const tempPlayer = new Stickman(remoteState.x, remoteState.color, remoteState.id, remoteState.name);
                tempPlayer.draw(remoteState);
            });

            // Draw Local Player last (on top)
            if (localPlayer) {
                localPlayer.draw();
            }

            // Draw Local Bullets
            bullets.forEach(bullet => bullet.draw());
            
            // Show player count
             ctx.font = '14px Inter';
             ctx.textAlign = 'right';
             ctx.fillStyle = '#ffffff';
             ctx.fillText(`Warriors Online: ${Object.keys(remotePlayers).length + (localPlayer ? 1 : 0)}`, canvas.width - 10, 20);
        } else {
             ctx.font = '24px Inter';
             ctx.textAlign = 'center';
             ctx.fillStyle = '#ffffff';
             ctx.fillText('LOADING ARENA...', canvas.width / 2, canvas.height / 2);
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- INPUT HANDLERS ---
    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = true;
        
        // Prevent default actions for control keys
        if (['a', 'd', 'w', 's', 'f', 'g'].includes(key)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
    });
    
    // --- EVENT LISTENERS ---
    window.addEventListener('load', () => {
        setCanvasSize();
        initializeFirebase();
        googleSignInBtn.addEventListener('click', handleGoogleSignIn);
    });
    window.addEventListener('resize', setCanvasSize);
    
    // --- Graceful Disconnect on tab close/refresh ---
    window.addEventListener('beforeunload', async () => {
        if (localPlayerId && db) {
            const playerRef = doc(db, PLAYER_COLLECTION_PATH, localPlayerId);
            // This is a best-effort attempt; the connection listener is better
            await setDoc(playerRef, { health: 0, lastUpdated: Date.now() }, { merge: true });
        }
    });

</script>

</body>
</html>
